// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: goals.sql

package repo

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createGoal = `-- name: CreateGoal :one
INSERT INTO goals (
    user_id, title, color, category_type
) VALUES (
    $1, $2, $3, $4
)
RETURNING id, user_id, title, color, category_type, is_archived, created_at
`

type CreateGoalParams struct {
	UserID       int32             `json:"user_id"`
	Title        string            `json:"title"`
	Color        pgtype.Text       `json:"color"`
	CategoryType GoalsCategoryType `json:"category_type"`
}

func (q *Queries) CreateGoal(ctx context.Context, arg CreateGoalParams) (Goal, error) {
	row := q.db.QueryRow(ctx, createGoal,
		arg.UserID,
		arg.Title,
		arg.Color,
		arg.CategoryType,
	)
	var i Goal
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Color,
		&i.CategoryType,
		&i.IsArchived,
		&i.CreatedAt,
	)
	return i, err
}

const deleteGoalByID = `-- name: DeleteGoalByID :exec
DELETE FROM goals
WHERE id = $1 AND user_id = $2
`

type DeleteGoalByIDParams struct {
	ID     int64 `json:"id"`
	UserID int32 `json:"user_id"`
}

func (q *Queries) DeleteGoalByID(ctx context.Context, arg DeleteGoalByIDParams) error {
	_, err := q.db.Exec(ctx, deleteGoalByID, arg.ID, arg.UserID)
	return err
}

const getGoalByID = `-- name: GetGoalByID :one
SELECT id, user_id, title, color, category_type, is_archived, created_at FROM goals
WHERE id = $1 AND user_id = $2 LIMIT 1
`

type GetGoalByIDParams struct {
	ID     int64 `json:"id"`
	UserID int32 `json:"user_id"`
}

func (q *Queries) GetGoalByID(ctx context.Context, arg GetGoalByIDParams) (Goal, error) {
	row := q.db.QueryRow(ctx, getGoalByID, arg.ID, arg.UserID)
	var i Goal
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Color,
		&i.CategoryType,
		&i.IsArchived,
		&i.CreatedAt,
	)
	return i, err
}

const listGoals = `-- name: ListGoals :many
SELECT id, user_id, title, color, category_type, is_archived, created_at FROM goals
WHERE user_id = $1
ORDER BY id
`

func (q *Queries) ListGoals(ctx context.Context, userID int32) ([]Goal, error) {
	rows, err := q.db.Query(ctx, listGoals, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Goal
	for rows.Next() {
		var i Goal
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Color,
			&i.CategoryType,
			&i.IsArchived,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listGoalsByIsArchived = `-- name: ListGoalsByIsArchived :many
SELECT id, user_id, title, color, category_type, is_archived, created_at FROM goals
WHERE is_archived = $1 AND user_id = $2
ORDER BY id
`

type ListGoalsByIsArchivedParams struct {
	IsArchived bool  `json:"is_archived"`
	UserID     int32 `json:"user_id"`
}

func (q *Queries) ListGoalsByIsArchived(ctx context.Context, arg ListGoalsByIsArchivedParams) ([]Goal, error) {
	rows, err := q.db.Query(ctx, listGoalsByIsArchived, arg.IsArchived, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Goal
	for rows.Next() {
		var i Goal
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Color,
			&i.CategoryType,
			&i.IsArchived,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateGoalByID = `-- name: UpdateGoalByID :one
UPDATE goals
SET title = $3, color = $4, category_type = $5, is_archived = $6
WHERE id = $1 AND user_id = $2
RETURNING id, user_id, title, color, category_type, is_archived, created_at
`

type UpdateGoalByIDParams struct {
	ID           int64             `json:"id"`
	UserID       int32             `json:"user_id"`
	Title        string            `json:"title"`
	Color        pgtype.Text       `json:"color"`
	CategoryType GoalsCategoryType `json:"category_type"`
	IsArchived   bool              `json:"is_archived"`
}

func (q *Queries) UpdateGoalByID(ctx context.Context, arg UpdateGoalByIDParams) (Goal, error) {
	row := q.db.QueryRow(ctx, updateGoalByID,
		arg.ID,
		arg.UserID,
		arg.Title,
		arg.Color,
		arg.CategoryType,
		arg.IsArchived,
	)
	var i Goal
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Color,
		&i.CategoryType,
		&i.IsArchived,
		&i.CreatedAt,
	)
	return i, err
}
