// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: tasks.sql

package repo

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countCompletedTasksForToday = `-- name: CountCompletedTasksForToday :one
SELECT
    count(*) FILTER (WHERE scheduled_date = current_date)::int AS total_today,
    count(*) FILTER (WHERE scheduled_date = current_date AND is_done = true)::int AS completed_today
FROM tasks
WHERE user_id = $1
`

type CountCompletedTasksForTodayRow struct {
	TotalToday     int32 `json:"total_today"`
	CompletedToday int32 `json:"completed_today"`
}

func (q *Queries) CountCompletedTasksForToday(ctx context.Context, userID int32) (CountCompletedTasksForTodayRow, error) {
	row := q.db.QueryRow(ctx, countCompletedTasksForToday, userID)
	var i CountCompletedTasksForTodayRow
	err := row.Scan(&i.TotalToday, &i.CompletedToday)
	return i, err
}

const createTask = `-- name: CreateTask :one
INSERT INTO tasks (
    user_id, goal_id, title, scheduled_date, scheduled_time, duration_minutes
) VALUES (
             $1, $2, $3, $4, $5, $6
         )
    RETURNING id, user_id, goal_id, title, is_done, scheduled_date, scheduled_time, duration_minutes, reschedule_count, created_at
`

type CreateTaskParams struct {
	UserID          int32       `json:"user_id"`
	GoalID          int32       `json:"goal_id"`
	Title           string      `json:"title"`
	ScheduledDate   pgtype.Date `json:"scheduled_date"`
	ScheduledTime   pgtype.Time `json:"scheduled_time"`
	DurationMinutes pgtype.Int4 `json:"duration_minutes"`
}

func (q *Queries) CreateTask(ctx context.Context, arg CreateTaskParams) (Task, error) {
	row := q.db.QueryRow(ctx, createTask,
		arg.UserID,
		arg.GoalID,
		arg.Title,
		arg.ScheduledDate,
		arg.ScheduledTime,
		arg.DurationMinutes,
	)
	var i Task
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.GoalID,
		&i.Title,
		&i.IsDone,
		&i.ScheduledDate,
		&i.ScheduledTime,
		&i.DurationMinutes,
		&i.RescheduleCount,
		&i.CreatedAt,
	)
	return i, err
}

const deleteTaskByID = `-- name: DeleteTaskByID :exec
DELETE FROM tasks
WHERE id = $1 AND user_id = $2
`

type DeleteTaskByIDParams struct {
	ID     int64 `json:"id"`
	UserID int32 `json:"user_id"`
}

func (q *Queries) DeleteTaskByID(ctx context.Context, arg DeleteTaskByIDParams) error {
	_, err := q.db.Exec(ctx, deleteTaskByID, arg.ID, arg.UserID)
	return err
}

const getTaskByID = `-- name: GetTaskByID :one
SELECT id, user_id, goal_id, title, is_done, scheduled_date, scheduled_time, duration_minutes, reschedule_count, created_at FROM tasks
WHERE id = $1 AND user_id = $2 LIMIT 1
`

type GetTaskByIDParams struct {
	ID     int64 `json:"id"`
	UserID int32 `json:"user_id"`
}

func (q *Queries) GetTaskByID(ctx context.Context, arg GetTaskByIDParams) (Task, error) {
	row := q.db.QueryRow(ctx, getTaskByID, arg.ID, arg.UserID)
	var i Task
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.GoalID,
		&i.Title,
		&i.IsDone,
		&i.ScheduledDate,
		&i.ScheduledTime,
		&i.DurationMinutes,
		&i.RescheduleCount,
		&i.CreatedAt,
	)
	return i, err
}

const listInboxTasks = `-- name: ListInboxTasks :many
SELECT id, user_id, goal_id, title, is_done, scheduled_date, scheduled_time, duration_minutes, reschedule_count, created_at FROM tasks
WHERE scheduled_date IS null AND is_done = false AND user_id = $1
ORDER BY id DESC
`

func (q *Queries) ListInboxTasks(ctx context.Context, userID int32) ([]Task, error) {
	rows, err := q.db.Query(ctx, listInboxTasks, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Task
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.GoalID,
			&i.Title,
			&i.IsDone,
			&i.ScheduledDate,
			&i.ScheduledTime,
			&i.DurationMinutes,
			&i.RescheduleCount,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTasks = `-- name: ListTasks :many
SELECT id, user_id, goal_id, title, is_done, scheduled_date, scheduled_time, duration_minutes, reschedule_count, created_at FROM tasks
WHERE user_id = $1
ORDER BY id
`

func (q *Queries) ListTasks(ctx context.Context, userID int32) ([]Task, error) {
	rows, err := q.db.Query(ctx, listTasks, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Task
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.GoalID,
			&i.Title,
			&i.IsDone,
			&i.ScheduledDate,
			&i.ScheduledTime,
			&i.DurationMinutes,
			&i.RescheduleCount,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTasksByDateRange = `-- name: ListTasksByDateRange :many
SELECT id, user_id, goal_id, title, is_done, scheduled_date, scheduled_time, duration_minutes, reschedule_count, created_at FROM tasks
WHERE user_id = $3 AND scheduled_date >= $1 AND scheduled_date <= $2
ORDER BY scheduled_time ASC, id
`

type ListTasksByDateRangeParams struct {
	ScheduledDate   pgtype.Date `json:"scheduled_date"`
	ScheduledDate_2 pgtype.Date `json:"scheduled_date_2"`
	UserID          int32       `json:"user_id"`
}

func (q *Queries) ListTasksByDateRange(ctx context.Context, arg ListTasksByDateRangeParams) ([]Task, error) {
	rows, err := q.db.Query(ctx, listTasksByDateRange, arg.ScheduledDate, arg.ScheduledDate_2, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Task
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.GoalID,
			&i.Title,
			&i.IsDone,
			&i.ScheduledDate,
			&i.ScheduledTime,
			&i.DurationMinutes,
			&i.RescheduleCount,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTasksByGoalID = `-- name: ListTasksByGoalID :many
SELECT id, user_id, goal_id, title, is_done, scheduled_date, scheduled_time, duration_minutes, reschedule_count, created_at FROM tasks
WHERE goal_id = $1 AND user_id = $2
ORDER BY is_done ASC, id DESC
`

type ListTasksByGoalIDParams struct {
	GoalID int32 `json:"goal_id"`
	UserID int32 `json:"user_id"`
}

func (q *Queries) ListTasksByGoalID(ctx context.Context, arg ListTasksByGoalIDParams) ([]Task, error) {
	rows, err := q.db.Query(ctx, listTasksByGoalID, arg.GoalID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Task
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.GoalID,
			&i.Title,
			&i.IsDone,
			&i.ScheduledDate,
			&i.ScheduledTime,
			&i.DurationMinutes,
			&i.RescheduleCount,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTaskByID = `-- name: UpdateTaskByID :exec
UPDATE tasks
SET
    goal_id = $3,
    title = $4,
    is_done = $5,
    scheduled_date = $6,
    scheduled_time = $7,
    duration_minutes = $8,
    reschedule_count = $9
WHERE id = $1 AND user_id = $2
`

type UpdateTaskByIDParams struct {
	ID              int64       `json:"id"`
	UserID          int32       `json:"user_id"`
	GoalID          int32       `json:"goal_id"`
	Title           string      `json:"title"`
	IsDone          bool        `json:"is_done"`
	ScheduledDate   pgtype.Date `json:"scheduled_date"`
	ScheduledTime   pgtype.Time `json:"scheduled_time"`
	DurationMinutes pgtype.Int4 `json:"duration_minutes"`
	RescheduleCount int32       `json:"reschedule_count"`
}

func (q *Queries) UpdateTaskByID(ctx context.Context, arg UpdateTaskByIDParams) error {
	_, err := q.db.Exec(ctx, updateTaskByID,
		arg.ID,
		arg.UserID,
		arg.GoalID,
		arg.Title,
		arg.IsDone,
		arg.ScheduledDate,
		arg.ScheduledTime,
		arg.DurationMinutes,
		arg.RescheduleCount,
	)
	return err
}
